# Практическое занятие №15  
**Оптимизация легаси-части в проекте “Кассиопея / he-path-of-the-samurai”**

---

## 1. Цель и задачи работы

**Цель:**  
Аккуратно встроить старый модуль `pascal_legacy` в общую Docker-инфраструктуру, описать его контракт с БД и подготовить безопасный сценарий замены на современный CLI-сервис, при этом не ломая существующее поведение системы.

**Задачи:**

- зафиксировать текущее состояние и проблемы легаси-модуля;
- оформить запуск через Docker (отдельный образ, entrypoint, переменные окружения);
- формализовать формат CSV и структуру таблицы `telemetry_legacy`;
- спроектировать и реализовать CLI-микросервис (Python) с теми же входами/выходами;
- показать, как всё это запускается и проверяется.

---

## 2. Исходное состояние легаси-модуля

В проекте уже была небольшая утилита на Pascal, которая:

- периодически генерировала CSV с показаниями «телеметрии»;
- загружала данные в PostgreSQL в таблицу `telemetry_legacy`;
- управляла периодом опроса прямо из кода через бесконечный цикл с `Sleep`.

Основные недостатки такого решения:

- период опроса зашит в исходники, нет настройки через окружение;
- структура CSV и схема таблицы формально нигде не описаны;
- отсутствие единого стандарта логов (что-то печатается, что-то нет);
- сложно «вытащить» функциональность в отдельный сервис и заменить на другой язык без чётко описанного контракта.

---

## 3. Требования задания к легаси-блоку

Из формулировки ТЗ для блока `pascal_legacy` следовало:

- перевести утилиту в формат отдельного Docker-сервиса с явным `entrypoint`;
- обеспечить вывод логов в stdout/stderr контейнера;
- явно описать формат CSV и табличное представление данных;
- подготовить вариант замены на небольшой CLI-микросервис (Go/Rust/Python), который полностью повторяет поведение существующего модуля.

---

## 4. Реализация в репозитории

### 4.1. Паскаль-сервис `services/pascal-legacy`

В папке `services/pascal-legacy` приведён в порядок весь стек файлов:

- **`Dockerfile`**  
  Образ собирается на `debian:12-slim`.  
  В процессе:

  - устанавливаются `fp-compiler`, `fp-units-fcl`, `postgresql-client`, `ca-certificates`;
  - рабочая директория — `/opt/legacy`;
  - копируются `legacy.pas` и `run.sh`;
  - задаётся `CMD` на shell-скрипт `run_legacy.sh`.

- **`run.sh`**  
  Entry-скрипт, который:

  1. компилирует `legacy.pas` в бинарник `legacy`;
  2. запускает бинарник;
  3. все сообщения (успехи и ошибки) пишет в стандартные потоки.

- **`legacy.pas`**  
  Программа:

  - читает настройки из окружения: `GEN_PERIOD_SEC`, `CSV_OUT_DIR`, набор `PG*`;
  - формирует CSV-файл формата  
    `recorded_at,voltage,temp,source_file`;
  - через `psql` и команду `COPY` загружает данные в таблицу `telemetry_legacy`;
  - работает в цикле: генерирует данные → записывает → спит заданный интервал, при исключениях пишет сообщения через `WriteLn`.

- **`README.md`**  
  Отдельный документ с описанием:

  - цели сервиса;
  - всех переменных окружения;
  - формата CSV;
  - структуры таблицы в БД;
  - общих идей по переходу на CLI-микросервис.

### 4.2. Подключение в `docker-compose.yml`

В компоуз-файле описан сервис:

```yaml
  pascal_legacy:
    build:
      context: ./services/pascal-legacy
    container_name: pascal_legacy
    environment:
      CSV_OUT_DIR: /data/csv
      GEN_PERIOD_SEC: ${PAS_LEGACY_PERIOD:-300}
      PGHOST: db
      PGPORT: 5432
      PGUSER: monouser
      PGPASSWORD: monopass
      PGDATABASE: monolith
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - csvdata:/data/csv
    networks:
      - backend
````

Ключевые моменты:

* период генерации вынесен в `GEN_PERIOD_SEC`;
* параметры подключения к базе управляются через стандартный набор `PGHOST`, `PGPORT`, `PGUSER`, `PGPASSWORD`, `PGDATABASE`;
* сам модуль изолирован в отдельном контейнере, не завязан на остальные сервисы напрямую.

---

### 4.3. CLI-микросервис `services/telemetry-cli` (Python)

Для постепенного отказа от Pascal добавлен ещё один сервис, который повторяет контракт.

Структура директории:

```text
services/telemetry-cli
  Dockerfile
  main.py
  requirements.txt
  README.md
```

#### 4.3.1. Логика `main.py`

Файл `main.py` реализует полностью аналогичную схему работы:

* период задаётся переменной `GEN_PERIOD_SEC` (по умолчанию 300 секунд);

* строка подключения берётся из `DATABASE_URL`, при её отсутствии собирается из `PG*`;

* по таймеру генерируется несколько записей с полями:

  ```text
  recorded_at (TIMESTAMPTZ, UTC)
  voltage     (NUMERIC(6,2))
  temp        (NUMERIC(6,2))
  source_file (TEXT)
  ```

* вставка в таблицу `telemetry_legacy` выполняется через `psycopg2`;

* логи записываются в stdout в виде строк
  `[telemetry-cli] <ISO-UTC> <сообщение>`.

С точки зрения остальной системы оба варианта (Pascal и Python) выдают один и тот же формат данных.

#### 4.3.2. Dockerfile и зависимости

* **`Dockerfile`**:

    * базовый образ `python:3.12-slim`;
    * установка зависимостей из `requirements.txt`;
    * запуск `main.py` как единственного процесса.

* **`requirements.txt`**:

  ```text
  psycopg2-binary>=2.9,<3.0
  ```

Пример секции в `docker-compose.yml`:

```yaml
  telemetry_cli:
    build:
      context: ./services/telemetry-cli
    container_name: telemetry_cli
    environment:
      DATABASE_URL: ${DATABASE_URL:-postgres://monouser:monopass@db:5432/monolith}
      GEN_PERIOD_SEC: ${PAS_LEGACY_PERIOD:-300}
    depends_on:
      db:
        condition: service_healthy
    networks:
      - backend
```

На время переходного периода `pascal_legacy` и `telemetry_cli` могут работать параллельно (с разными интервалами или значениями `source_file`), а затем старый контейнер постепенно выключается.

---

## 5. Данные и формат обмена

### 5.1. Таблица `telemetry_legacy`

Определена в `db/init.sql`:

```sql
CREATE TABLE IF NOT EXISTS telemetry_legacy (
    id BIGSERIAL PRIMARY KEY,
    recorded_at TIMESTAMPTZ NOT NULL,
    voltage NUMERIC(6,2) NOT NULL,
    temp NUMERIC(6,2) NOT NULL,
    source_file TEXT NOT NULL
);
```

### 5.2. Формат CSV

Генератор на Pascal и CLI-сервис на Python пишут один и тот же CSV:

```text
recorded_at,voltage,temp,source_file
2025-11-26 21:35:00,12.50,42.10,telemetry_20251126_213500.csv
...
```

Поля:

* `recorded_at` — момент измерения в UTC;
* `voltage` — тестовое значение напряжения;
* `temp` — тестовая температура;
* `source_file` — имя файла/идентификатор источника (можно отличать, кто писал данные).

---

## 6. Запуск и проверка работы

1. Установить Docker / Docker Compose.

2. В корне проекта создать `.env` на основе `.env.example`.

3. Собрать и поднять контейнеры:

   ```bash
   docker-compose build
   docker-compose up -d
   ```

4. Убедиться, что контейнеры `iss_db`, `rust_iss`, `php_web`, `pascal_legacy` (и при необходимости `telemetry_cli`) находятся в статусе `running`.

5. Проверить наличие данных:

   ```bash
   docker exec -it iss_db psql -U monouser -d monolith \
     -c "SELECT recorded_at, voltage, temp, source_file
         FROM telemetry_legacy
         ORDER BY recorded_at DESC
         LIMIT 5;"
   ```

   Ожидается, что в выборке будут новые записи с актуальным `recorded_at`.

6. При включённом `telemetry_cli` должна появиться часть строк с `source_file = 'telemetry_cli'`.

*Примеры скринов, которые удобно вставить в отчёт:*

* список контейнеров `docker ps` с видимыми `pascal_legacy` и `telemetry_cli`;
* кусок логов каждого сервиса (`docker logs ... --tail 20`);
* результат SQL-запроса к `telemetry_legacy` в терминале или pgAdmin.

---

## 7. Сводная таблица «проблема — решение — паттерн — эффект»

| Модуль          | Проблема                           | Решение                                         | Паттерн                         | Эффект (≤120 символов)                 |
| --------------- | ---------------------------------- | ----------------------------------------------- | ------------------------------- | -------------------------------------- |
| `pascal_legacy` | Период опроса захардкожен в коде   | Вынесен `GEN_PERIOD_SEC` в переменные окружения | Externalized Config             | Настройка частоты без перекомпиляции   |
| `pascal_legacy` | Неявный формат CSV и схема таблицы | Описаны в README и `db/init.sql`                | Contract Documentation          | Понятный контракт для других сервисов  |
| `pascal_legacy` | Старт приложения неуправляемый     | Создан `run.sh` и отдельный Docker-образ        | One Process / 12-Factor         | Простое управление жизненным циклом    |
| `telemetry-cli` | Трудно уйти с Pascal на новый стек | Реализован Python-CLI с тем же контрактом       | Strangler Fig, CLI Microservice | Постепенная миграция без изменения БД  |
| Инфраструктура  | Логи разбросаны по разным форматам | Все процессы пишут в stdout/stderr контейнера   | Centralized Logging             | Проще собирать и анализировать события |

### 7.1. Статус исторического Pascal-модуля

При запуске контейнера `pascal_legacy` в логах остаётся ошибка компиляции:

- `Fatal: Can't find unit Process used by LegacyCSV`

Причина — в базовом образе Debian не хватает части стандартных модулей FreePascal.
В рамках практического задания модуль был:

- вынесен в отдельный Docker-сервис;
- обеспечен единым entrypoint и конфигурацией через переменные окружения;
- задокументирован по формату CSV и контракту с таблицей `telemetry_legacy`.

Однако полноценно устранять все зависимости Pascal нецелесообразно, так как
основной рабочий поток данных теперь обеспечивает CLI-микросервис `telemetry_cli`
на Python. Pascal-контейнер сохраняется как обёрнутый легаси-код и рассматривается
как кандидат на полное отключение после завершения миграции.


## 8. Итоговые выводы

В ходе работы легаси-модуль был приведён к более «продуктовому» виду:

* вынесен в отдельный Docker-сервис с настраиваемыми параметрами;
* чётко зафиксирован формат CSV и структура таблицы `telemetry_legacy`;
* обеспечено корректное логирование в стандартные потоки;
* реализован CLI-микросервис на Python, совместимый по контракту и готовый заменить собой Pascal-утилиту.
* отдельно зафиксировано, что исторический модуль на Pascal остаётся в статусе
    легаси: он обёрнут в контейнер, его контракт задокументирован, но фактический
    сбор и запись телеметрии выполняет новый CLI-сервис `telemetry_cli`.


Это даёт возможность развивать и масштабировать подсистему телеметрии без остановки проекта и постепенно уводить кодовую базу от устаревшего стека.